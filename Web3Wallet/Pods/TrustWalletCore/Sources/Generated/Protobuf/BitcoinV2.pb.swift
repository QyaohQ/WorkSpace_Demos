// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: BitcoinV2.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum TW_BitcoinV2_Proto_InputSelector: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Automatically select enough inputs in an ascending order to cover the outputs of the transaction.
  case selectAscending // = 0

  /// Automatically select enough inputs in the given order to cover the outputs of the transaction.
  case selectInOrder // = 1

  /// Automatically select enough inputs in an descending order to cover the outputs of the transaction.
  case selectDescending // = 2

  /// Use all the inputs provided in the given order.
  case useAll // = 10
  case UNRECOGNIZED(Int)

  public init() {
    self = .selectAscending
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .selectAscending
    case 1: self = .selectInOrder
    case 2: self = .selectDescending
    case 10: self = .useAll
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .selectAscending: return 0
    case .selectInOrder: return 1
    case .selectDescending: return 2
    case .useAll: return 10
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension TW_BitcoinV2_Proto_InputSelector: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [TW_BitcoinV2_Proto_InputSelector] = [
    .selectAscending,
    .selectInOrder,
    .selectDescending,
    .useAll,
  ]
}

#endif  // swift(>=4.2)

public enum TW_BitcoinV2_Proto_TransactionVersion: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// V1 is used by default.
  case useDefault // = 0

  /// Original transaction version.
  case v1 // = 1

  /// https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki#specification
  case v2 // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .useDefault
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .useDefault
    case 1: self = .v1
    case 2: self = .v2
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .useDefault: return 0
    case .v1: return 1
    case .v2: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension TW_BitcoinV2_Proto_TransactionVersion: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [TW_BitcoinV2_Proto_TransactionVersion] = [
    .useDefault,
    .v1,
    .v2,
  ]
}

#endif  // swift(>=4.2)

/// Either a public key or public key hash.
public struct TW_BitcoinV2_Proto_PublicKeyOrHash {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var variant: TW_BitcoinV2_Proto_PublicKeyOrHash.OneOf_Variant? = nil

  /// Public key bytes.
  public var pubkey: Data {
    get {
      if case .pubkey(let v)? = variant {return v}
      return Data()
    }
    set {variant = .pubkey(newValue)}
  }

  /// Public key hash.
  public var hash: Data {
    get {
      if case .hash(let v)? = variant {return v}
      return Data()
    }
    set {variant = .hash(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Variant: Equatable {
    /// Public key bytes.
    case pubkey(Data)
    /// Public key hash.
    case hash(Data)

  #if !swift(>=4.1)
    public static func ==(lhs: TW_BitcoinV2_Proto_PublicKeyOrHash.OneOf_Variant, rhs: TW_BitcoinV2_Proto_PublicKeyOrHash.OneOf_Variant) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.pubkey, .pubkey): return {
        guard case .pubkey(let l) = lhs, case .pubkey(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.hash, .hash): return {
        guard case .hash(let l) = lhs, case .hash(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Bitcoin transaction out-point reference.
public struct TW_BitcoinV2_Proto_OutPoint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The hash of the referenced transaction (network byte order, usually needs to be reversed).
  /// The referenced transaction ID in REVERSED order.
  public var hash: Data = Data()

  /// The position in the previous transactions output that this input references.
  public var vout: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct TW_BitcoinV2_Proto_Input {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Reference to the previous transaction's output.
  public var outPoint: TW_BitcoinV2_Proto_OutPoint {
    get {return _outPoint ?? TW_BitcoinV2_Proto_OutPoint()}
    set {_outPoint = newValue}
  }
  /// Returns true if `outPoint` has been explicitly set.
  public var hasOutPoint: Bool {return self._outPoint != nil}
  /// Clears the value of `outPoint`. Subsequent reads from it will return its default value.
  public mutating func clearOutPoint() {self._outPoint = nil}

  /// The amount of satoshis of this input.
  public var value: Int64 = 0

  /// The sighash type, normally `All`.
  /// See `TWBitcoinSigHashType` enum.
  public var sighashType: UInt32 = 0

  /// Optional sequence number, used for timelocks, replace-by-fee, etc.
  /// Leave empty to use a default 4294967295 (0xFFFFFFFF) value.
  public var sequence: TW_BitcoinV2_Proto_Input.Sequence {
    get {return _sequence ?? TW_BitcoinV2_Proto_Input.Sequence()}
    set {_sequence = newValue}
  }
  /// Returns true if `sequence` has been explicitly set.
  public var hasSequence: Bool {return self._sequence != nil}
  /// Clears the value of `sequence`. Subsequent reads from it will return its default value.
  public mutating func clearSequence() {self._sequence = nil}

  /// Script for claiming this UTXO.
  public var claimingScript: TW_BitcoinV2_Proto_Input.OneOf_ClaimingScript? = nil

  /// Construct claiming script with a builder pattern.
  public var scriptBuilder: TW_BitcoinV2_Proto_Input.InputBuilder {
    get {
      if case .scriptBuilder(let v)? = claimingScript {return v}
      return TW_BitcoinV2_Proto_Input.InputBuilder()
    }
    set {claimingScript = .scriptBuilder(newValue)}
  }

  /// Spending script pubkey data.
  /// Use this variant if the UTXO claiming script is known already, otherwise use `InputBuilder`.
  /// Please note that the signing method (eg "legacy" or "segwit") will be determined by parsing the script data as:
  /// - P2PK, P2PKH - legacy signing method;
  /// - P2WPKH - segwit signing method.
  public var scriptData: Data {
    get {
      if case .scriptData(let v)? = claimingScript {return v}
      return Data()
    }
    set {claimingScript = .scriptData(newValue)}
  }

  /// Derive a spending script pubkey from a receiver address.
  /// E.g "bc1" segwit address will be P2WPKH claiming script.
  /// TODO consider deprecating this because we can't determine if the script pubkey is P2PK or P2PKH actually.
  public var receiverAddress: String {
    get {
      if case .receiverAddress(let v)? = claimingScript {return v}
      return String()
    }
    set {claimingScript = .receiverAddress(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Script for claiming this UTXO.
  public enum OneOf_ClaimingScript: Equatable {
    /// Construct claiming script with a builder pattern.
    case scriptBuilder(TW_BitcoinV2_Proto_Input.InputBuilder)
    /// Spending script pubkey data.
    /// Use this variant if the UTXO claiming script is known already, otherwise use `InputBuilder`.
    /// Please note that the signing method (eg "legacy" or "segwit") will be determined by parsing the script data as:
    /// - P2PK, P2PKH - legacy signing method;
    /// - P2WPKH - segwit signing method.
    case scriptData(Data)
    /// Derive a spending script pubkey from a receiver address.
    /// E.g "bc1" segwit address will be P2WPKH claiming script.
    /// TODO consider deprecating this because we can't determine if the script pubkey is P2PK or P2PKH actually.
    case receiverAddress(String)

  #if !swift(>=4.1)
    public static func ==(lhs: TW_BitcoinV2_Proto_Input.OneOf_ClaimingScript, rhs: TW_BitcoinV2_Proto_Input.OneOf_ClaimingScript) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.scriptBuilder, .scriptBuilder): return {
        guard case .scriptBuilder(let l) = lhs, case .scriptBuilder(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.scriptData, .scriptData): return {
        guard case .scriptData(let l) = lhs, case .scriptData(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.receiverAddress, .receiverAddress): return {
        guard case .receiverAddress(let l) = lhs, case .receiverAddress(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// Optional sequence number, used for timelocks, replace-by-fee, etc.
  public struct Sequence {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var sequence: UInt32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct InputBuilder {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Pay-to-Script-Hash, specify the redeem script.
    /// Please note that we support standard redeem scripts only, such as P2PKH, P2WPKH, P2TR.
    /// TODO next iteration.
    /// bytes p2sh = 1;
    public var variant: TW_BitcoinV2_Proto_Input.InputBuilder.OneOf_Variant? = nil

    /// Pay-to-Public-Key, specify the public key.
    public var p2Pk: Data {
      get {
        if case .p2Pk(let v)? = variant {return v}
        return Data()
      }
      set {variant = .p2Pk(newValue)}
    }

    /// Pay-to-Public-Key-Hash, specify the public key.
    public var p2Pkh: TW_BitcoinV2_Proto_PublicKeyOrHash {
      get {
        if case .p2Pkh(let v)? = variant {return v}
        return TW_BitcoinV2_Proto_PublicKeyOrHash()
      }
      set {variant = .p2Pkh(newValue)}
    }

    /// Pay-to-Public-Key-Hash, specify the public key.
    public var p2Wpkh: TW_BitcoinV2_Proto_PublicKeyOrHash {
      get {
        if case .p2Wpkh(let v)? = variant {return v}
        return TW_BitcoinV2_Proto_PublicKeyOrHash()
      }
      set {variant = .p2Wpkh(newValue)}
    }

    /// Pay-to-Taproot-key-path (balance transfers), specify the public key.
    public var p2TrKeyPath: Data {
      get {
        if case .p2TrKeyPath(let v)? = variant {return v}
        return Data()
      }
      set {variant = .p2TrKeyPath(newValue)}
    }

    /// Create a BRC20 inscription.
    public var brc20Inscribe: TW_BitcoinV2_Proto_Input.InputBrc20Inscription {
      get {
        if case .brc20Inscribe(let v)? = variant {return v}
        return TW_BitcoinV2_Proto_Input.InputBrc20Inscription()
      }
      set {variant = .brc20Inscribe(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Pay-to-Script-Hash, specify the redeem script.
    /// Please note that we support standard redeem scripts only, such as P2PKH, P2WPKH, P2TR.
    /// TODO next iteration.
    /// bytes p2sh = 1;
    public enum OneOf_Variant: Equatable {
      /// Pay-to-Public-Key, specify the public key.
      case p2Pk(Data)
      /// Pay-to-Public-Key-Hash, specify the public key.
      case p2Pkh(TW_BitcoinV2_Proto_PublicKeyOrHash)
      /// Pay-to-Public-Key-Hash, specify the public key.
      case p2Wpkh(TW_BitcoinV2_Proto_PublicKeyOrHash)
      /// Pay-to-Taproot-key-path (balance transfers), specify the public key.
      case p2TrKeyPath(Data)
      /// Create a BRC20 inscription.
      case brc20Inscribe(TW_BitcoinV2_Proto_Input.InputBrc20Inscription)

    #if !swift(>=4.1)
      public static func ==(lhs: TW_BitcoinV2_Proto_Input.InputBuilder.OneOf_Variant, rhs: TW_BitcoinV2_Proto_Input.InputBuilder.OneOf_Variant) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.p2Pk, .p2Pk): return {
          guard case .p2Pk(let l) = lhs, case .p2Pk(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.p2Pkh, .p2Pkh): return {
          guard case .p2Pkh(let l) = lhs, case .p2Pkh(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.p2Wpkh, .p2Wpkh): return {
          guard case .p2Wpkh(let l) = lhs, case .p2Wpkh(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.p2TrKeyPath, .p2TrKeyPath): return {
          guard case .p2TrKeyPath(let l) = lhs, case .p2TrKeyPath(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.brc20Inscribe, .brc20Inscribe): return {
          guard case .brc20Inscribe(let l) = lhs, case .brc20Inscribe(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public init() {}
  }

  public struct InputTaprootScriptPath {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The payload of the Taproot transaction.
    public var payload: Data = Data()

    /// The control block of the Taproot transaction required for claiming.
    public var controlBlock: Data = Data()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct InputBrc20Inscription {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The recipient of the inscription, usually the sender.
    public var inscribeTo: Data = Data()

    /// The ticker of the BRC20 inscription.
    public var ticker: String = String()

    /// The BRC20 token transfer amount.
    public var transferAmount: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _outPoint: TW_BitcoinV2_Proto_OutPoint? = nil
  fileprivate var _sequence: TW_BitcoinV2_Proto_Input.Sequence? = nil
}

public struct TW_BitcoinV2_Proto_Output {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The amount of satoshis to send.
  public var value: Int64 = 0

  public var toRecipient: TW_BitcoinV2_Proto_Output.OneOf_ToRecipient? = nil

  /// Construct output with builder pattern.
  public var builder: TW_BitcoinV2_Proto_Output.OutputBuilder {
    get {
      if case .builder(let v)? = toRecipient {return v}
      return TW_BitcoinV2_Proto_Output.OutputBuilder()
    }
    set {toRecipient = .builder(newValue)}
  }

  /// Construct output by providing the scriptPubkey directly.
  public var customScriptPubkey: Data {
    get {
      if case .customScriptPubkey(let v)? = toRecipient {return v}
      return Data()
    }
    set {toRecipient = .customScriptPubkey(newValue)}
  }

  /// Derive the expected output from the provided address.
  public var toAddress: String {
    get {
      if case .toAddress(let v)? = toRecipient {return v}
      return String()
    }
    set {toRecipient = .toAddress(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_ToRecipient: Equatable {
    /// Construct output with builder pattern.
    case builder(TW_BitcoinV2_Proto_Output.OutputBuilder)
    /// Construct output by providing the scriptPubkey directly.
    case customScriptPubkey(Data)
    /// Derive the expected output from the provided address.
    case toAddress(String)

  #if !swift(>=4.1)
    public static func ==(lhs: TW_BitcoinV2_Proto_Output.OneOf_ToRecipient, rhs: TW_BitcoinV2_Proto_Output.OneOf_ToRecipient) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.builder, .builder): return {
        guard case .builder(let l) = lhs, case .builder(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.customScriptPubkey, .customScriptPubkey): return {
        guard case .customScriptPubkey(let l) = lhs, case .customScriptPubkey(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.toAddress, .toAddress): return {
        guard case .toAddress(let l) = lhs, case .toAddress(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public struct OutputBuilder {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var variant: TW_BitcoinV2_Proto_Output.OutputBuilder.OneOf_Variant? = nil

    /// Pay-to-Script-Hash, specify the redeem script or its hash.
    public var p2Sh: TW_BitcoinV2_Proto_Output.RedeemScriptOrHash {
      get {
        if case .p2Sh(let v)? = variant {return v}
        return TW_BitcoinV2_Proto_Output.RedeemScriptOrHash()
      }
      set {variant = .p2Sh(newValue)}
    }

    /// Pay-to-Public-Key, specify the public key.
    public var p2Pk: Data {
      get {
        if case .p2Pk(let v)? = variant {return v}
        return Data()
      }
      set {variant = .p2Pk(newValue)}
    }

    /// Pay-to-Public-Key-Hash, specify the public key or its hash.
    public var p2Pkh: TW_BitcoinV2_Proto_PublicKeyOrHash {
      get {
        if case .p2Pkh(let v)? = variant {return v}
        return TW_BitcoinV2_Proto_PublicKeyOrHash()
      }
      set {variant = .p2Pkh(newValue)}
    }

    /// Pay-to-Witness-Script-Hash, specify the redeem script or its hash.
    public var p2Wsh: TW_BitcoinV2_Proto_Output.RedeemScriptOrHash {
      get {
        if case .p2Wsh(let v)? = variant {return v}
        return TW_BitcoinV2_Proto_Output.RedeemScriptOrHash()
      }
      set {variant = .p2Wsh(newValue)}
    }

    /// Pay-to-Public-Key-Hash, specify the public key or its hash.
    public var p2Wpkh: TW_BitcoinV2_Proto_PublicKeyOrHash {
      get {
        if case .p2Wpkh(let v)? = variant {return v}
        return TW_BitcoinV2_Proto_PublicKeyOrHash()
      }
      set {variant = .p2Wpkh(newValue)}
    }

    /// Pay-to-Taproot-key-path (balance transfers), specify the public key.
    public var p2TrKeyPath: Data {
      get {
        if case .p2TrKeyPath(let v)? = variant {return v}
        return Data()
      }
      set {variant = .p2TrKeyPath(newValue)}
    }

    /// Pay-to-Taproot-script-path (complex transfers)
    public var p2TrScriptPath: TW_BitcoinV2_Proto_Output.OutputTaprootScriptPath {
      get {
        if case .p2TrScriptPath(let v)? = variant {return v}
        return TW_BitcoinV2_Proto_Output.OutputTaprootScriptPath()
      }
      set {variant = .p2TrScriptPath(newValue)}
    }

    public var p2TrDangerousAssumeTweaked: Data {
      get {
        if case .p2TrDangerousAssumeTweaked(let v)? = variant {return v}
        return Data()
      }
      set {variant = .p2TrDangerousAssumeTweaked(newValue)}
    }

    public var brc20Inscribe: TW_BitcoinV2_Proto_Output.OutputBrc20Inscription {
      get {
        if case .brc20Inscribe(let v)? = variant {return v}
        return TW_BitcoinV2_Proto_Output.OutputBrc20Inscription()
      }
      set {variant = .brc20Inscribe(newValue)}
    }

    /// OP_RETURN output. In most cases, with a zero-amount.
    public var opReturn: Data {
      get {
        if case .opReturn(let v)? = variant {return v}
        return Data()
      }
      set {variant = .opReturn(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Variant: Equatable {
      /// Pay-to-Script-Hash, specify the redeem script or its hash.
      case p2Sh(TW_BitcoinV2_Proto_Output.RedeemScriptOrHash)
      /// Pay-to-Public-Key, specify the public key.
      case p2Pk(Data)
      /// Pay-to-Public-Key-Hash, specify the public key or its hash.
      case p2Pkh(TW_BitcoinV2_Proto_PublicKeyOrHash)
      /// Pay-to-Witness-Script-Hash, specify the redeem script or its hash.
      case p2Wsh(TW_BitcoinV2_Proto_Output.RedeemScriptOrHash)
      /// Pay-to-Public-Key-Hash, specify the public key or its hash.
      case p2Wpkh(TW_BitcoinV2_Proto_PublicKeyOrHash)
      /// Pay-to-Taproot-key-path (balance transfers), specify the public key.
      case p2TrKeyPath(Data)
      /// Pay-to-Taproot-script-path (complex transfers)
      case p2TrScriptPath(TW_BitcoinV2_Proto_Output.OutputTaprootScriptPath)
      case p2TrDangerousAssumeTweaked(Data)
      case brc20Inscribe(TW_BitcoinV2_Proto_Output.OutputBrc20Inscription)
      /// OP_RETURN output. In most cases, with a zero-amount.
      case opReturn(Data)

    #if !swift(>=4.1)
      public static func ==(lhs: TW_BitcoinV2_Proto_Output.OutputBuilder.OneOf_Variant, rhs: TW_BitcoinV2_Proto_Output.OutputBuilder.OneOf_Variant) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.p2Sh, .p2Sh): return {
          guard case .p2Sh(let l) = lhs, case .p2Sh(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.p2Pk, .p2Pk): return {
          guard case .p2Pk(let l) = lhs, case .p2Pk(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.p2Pkh, .p2Pkh): return {
          guard case .p2Pkh(let l) = lhs, case .p2Pkh(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.p2Wsh, .p2Wsh): return {
          guard case .p2Wsh(let l) = lhs, case .p2Wsh(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.p2Wpkh, .p2Wpkh): return {
          guard case .p2Wpkh(let l) = lhs, case .p2Wpkh(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.p2TrKeyPath, .p2TrKeyPath): return {
          guard case .p2TrKeyPath(let l) = lhs, case .p2TrKeyPath(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.p2TrScriptPath, .p2TrScriptPath): return {
          guard case .p2TrScriptPath(let l) = lhs, case .p2TrScriptPath(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.p2TrDangerousAssumeTweaked, .p2TrDangerousAssumeTweaked): return {
          guard case .p2TrDangerousAssumeTweaked(let l) = lhs, case .p2TrDangerousAssumeTweaked(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.brc20Inscribe, .brc20Inscribe): return {
          guard case .brc20Inscribe(let l) = lhs, case .brc20Inscribe(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.opReturn, .opReturn): return {
          guard case .opReturn(let l) = lhs, case .opReturn(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public init() {}
  }

  /// Either a redeem script or its hash.
  public struct RedeemScriptOrHash {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var variant: TW_BitcoinV2_Proto_Output.RedeemScriptOrHash.OneOf_Variant? = nil

    /// Redeem script bytes.
    public var redeemScript: Data {
      get {
        if case .redeemScript(let v)? = variant {return v}
        return Data()
      }
      set {variant = .redeemScript(newValue)}
    }

    /// Public key hash.
    public var hash: Data {
      get {
        if case .hash(let v)? = variant {return v}
        return Data()
      }
      set {variant = .hash(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Variant: Equatable {
      /// Redeem script bytes.
      case redeemScript(Data)
      /// Public key hash.
      case hash(Data)

    #if !swift(>=4.1)
      public static func ==(lhs: TW_BitcoinV2_Proto_Output.RedeemScriptOrHash.OneOf_Variant, rhs: TW_BitcoinV2_Proto_Output.RedeemScriptOrHash.OneOf_Variant) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.redeemScript, .redeemScript): return {
          guard case .redeemScript(let l) = lhs, case .redeemScript(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.hash, .hash): return {
          guard case .hash(let l) = lhs, case .hash(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public init() {}
  }

  public struct OutputTaprootScriptPath {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The internal key, usually the public key of the recipient.
    public var internalKey: Data = Data()

    /// The merkle root of the Taproot script(s), required to compute the sighash.
    public var merkleRoot: Data = Data()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct OutputBrc20Inscription {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The recipient of the inscription, usually the sender.
    public var inscribeTo: Data = Data()

    /// The ticker of the BRC20 inscription.
    public var ticker: String = String()

    /// The BRC20 token transfer amount.
    public var transferAmount: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct TW_BitcoinV2_Proto_ChainInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// P2PKH prefix for this chain.
  public var p2PkhPrefix: UInt32 = 0

  /// P2SH prefix for this coin type.
  public var p2ShPrefix: UInt32 = 0

  /// HRP for this coin type if applicable.
  public var hrp: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Transaction builder used in `SigningInput`.
public struct TW_BitcoinV2_Proto_TransactionBuilder {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Transaction version.
  public var version: TW_BitcoinV2_Proto_TransactionVersion = .useDefault

  /// (optional) Block height or timestamp indicating at what point transactions can be included in a block.
  /// Zero by default.
  public var lockTime: UInt32 = 0

  /// The inputs to spend.
  public var inputs: [TW_BitcoinV2_Proto_Input] = []

  /// The output of the transaction. Note that the change output is specified
  /// in the `change_output` field.
  public var outputs: [TW_BitcoinV2_Proto_Output] = []

  /// How the inputs should be selected.
  public var inputSelector: TW_BitcoinV2_Proto_InputSelector = .selectAscending

  /// The amount of satoshis per vbyte ("satVb"), used for fee calculation.
  /// Can be satoshis per byte ("satB") **ONLY** when transaction does not contain segwit UTXOs.
  public var feePerVb: Int64 = 0

  /// (optional) The change output to be added (return to sender) at the end of the outputs list.
  /// The `Output.value` will be overwritten, leave default.
  /// Note there can be no change output if the change amount is less than dust threshold.
  /// Leave empty to explicitly disable change output creation.
  public var changeOutput: TW_BitcoinV2_Proto_Output {
    get {return _changeOutput ?? TW_BitcoinV2_Proto_Output()}
    set {_changeOutput = newValue}
  }
  /// Returns true if `changeOutput` has been explicitly set.
  public var hasChangeOutput: Bool {return self._changeOutput != nil}
  /// Clears the value of `changeOutput`. Subsequent reads from it will return its default value.
  public mutating func clearChangeOutput() {self._changeOutput = nil}

  /// The only output with a max available amount to be send.
  /// If set, `SigningInput.outputs` and `SigningInput.change` will be ignored.
  /// The `Output.value` will be overwritten, leave default.
  public var maxAmountOutput: TW_BitcoinV2_Proto_Output {
    get {return _maxAmountOutput ?? TW_BitcoinV2_Proto_Output()}
    set {_maxAmountOutput = newValue}
  }
  /// Returns true if `maxAmountOutput` has been explicitly set.
  public var hasMaxAmountOutput: Bool {return self._maxAmountOutput != nil}
  /// Clears the value of `maxAmountOutput`. Subsequent reads from it will return its default value.
  public mutating func clearMaxAmountOutput() {self._maxAmountOutput = nil}

  /// One of the "Dust" amount policies.
  /// Later, we plan to add support for `DynamicDust` policy with a `min_relay_fee` amount.
  public var dustPolicy: TW_BitcoinV2_Proto_TransactionBuilder.OneOf_DustPolicy? = nil

  /// Use a constant "Dust" threshold.
  public var fixedDustThreshold: Int64 {
    get {
      if case .fixedDustThreshold(let v)? = dustPolicy {return v}
      return 0
    }
    set {dustPolicy = .fixedDustThreshold(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// One of the "Dust" amount policies.
  /// Later, we plan to add support for `DynamicDust` policy with a `min_relay_fee` amount.
  public enum OneOf_DustPolicy: Equatable {
    /// Use a constant "Dust" threshold.
    case fixedDustThreshold(Int64)

  #if !swift(>=4.1)
    public static func ==(lhs: TW_BitcoinV2_Proto_TransactionBuilder.OneOf_DustPolicy, rhs: TW_BitcoinV2_Proto_TransactionBuilder.OneOf_DustPolicy) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.fixedDustThreshold, .fixedDustThreshold): return {
        guard case .fixedDustThreshold(let l) = lhs, case .fixedDustThreshold(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _changeOutput: TW_BitcoinV2_Proto_Output? = nil
  fileprivate var _maxAmountOutput: TW_BitcoinV2_Proto_Output? = nil
}

/// Partially Signed Bitcoin Transaction.
public struct TW_BitcoinV2_Proto_Psbt {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Partially Signed Bitcoin Transaction binary encoded.
  public var psbt: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct TW_BitcoinV2_Proto_SigningInput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// User private keys.
  /// Only required if the `sign` method is called.
  public var privateKeys: [Data] {
    get {return _storage._privateKeys}
    set {_uniqueStorage()._privateKeys = newValue}
  }

  /// User public keys.
  /// Only required if the `plan`, `preImageHash` methods are called.
  public var publicKeys: [Data] {
    get {return _storage._publicKeys}
    set {_uniqueStorage()._publicKeys = newValue}
  }

  /// Chain info includes p2pkh, p2sh address prefixes.
  /// The parameter needs to be set if an input/output has a receiver address pattern.
  public var chainInfo: TW_BitcoinV2_Proto_ChainInfo {
    get {return _storage._chainInfo ?? TW_BitcoinV2_Proto_ChainInfo()}
    set {_uniqueStorage()._chainInfo = newValue}
  }
  /// Returns true if `chainInfo` has been explicitly set.
  public var hasChainInfo: Bool {return _storage._chainInfo != nil}
  /// Clears the value of `chainInfo`. Subsequent reads from it will return its default value.
  public mutating func clearChainInfo() {_uniqueStorage()._chainInfo = nil}

  /// Whether disable auxiliary random data when signing.
  /// Use for testing **ONLY**.
  public var dangerousUseFixedSchnorrRng: Bool {
    get {return _storage._dangerousUseFixedSchnorrRng}
    set {_uniqueStorage()._dangerousUseFixedSchnorrRng = newValue}
  }

  /// The transaction signing type.
  public var transaction: OneOf_Transaction? {
    get {return _storage._transaction}
    set {_uniqueStorage()._transaction = newValue}
  }

  /// Build a transaction to be signed.
  public var builder: TW_BitcoinV2_Proto_TransactionBuilder {
    get {
      if case .builder(let v)? = _storage._transaction {return v}
      return TW_BitcoinV2_Proto_TransactionBuilder()
    }
    set {_uniqueStorage()._transaction = .builder(newValue)}
  }

  /// Finalize a Partially Signed Bitcoin Transaction by signing the rest of UTXOs.
  public var psbt: TW_BitcoinV2_Proto_Psbt {
    get {
      if case .psbt(let v)? = _storage._transaction {return v}
      return TW_BitcoinV2_Proto_Psbt()
    }
    set {_uniqueStorage()._transaction = .psbt(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The transaction signing type.
  public enum OneOf_Transaction: Equatable {
    /// Build a transaction to be signed.
    case builder(TW_BitcoinV2_Proto_TransactionBuilder)
    /// Finalize a Partially Signed Bitcoin Transaction by signing the rest of UTXOs.
    case psbt(TW_BitcoinV2_Proto_Psbt)

  #if !swift(>=4.1)
    public static func ==(lhs: TW_BitcoinV2_Proto_SigningInput.OneOf_Transaction, rhs: TW_BitcoinV2_Proto_SigningInput.OneOf_Transaction) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.builder, .builder): return {
        guard case .builder(let l) = lhs, case .builder(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.psbt, .psbt): return {
        guard case .psbt(let l) = lhs, case .psbt(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct TW_BitcoinV2_Proto_Transaction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The protocol version, is currently expected to be 1 or 2 (BIP68).
  public var version: Int32 = 0

  /// Block height or timestamp indicating at what point transactions can be included in a block.
  /// Zero by default.
  public var lockTime: UInt32 = 0

  /// The transaction inputs.
  public var inputs: [TW_BitcoinV2_Proto_Transaction.TransactionInput] = []

  /// The transaction outputs.
  public var outputs: [TW_BitcoinV2_Proto_Transaction.TransactionOutput] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct TransactionInput {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Reference to the previous transaction's output.
    public var outPoint: TW_BitcoinV2_Proto_OutPoint {
      get {return _outPoint ?? TW_BitcoinV2_Proto_OutPoint()}
      set {_outPoint = newValue}
    }
    /// Returns true if `outPoint` has been explicitly set.
    public var hasOutPoint: Bool {return self._outPoint != nil}
    /// Clears the value of `outPoint`. Subsequent reads from it will return its default value.
    public mutating func clearOutPoint() {self._outPoint = nil}

    /// The sequence number, used for timelocks, replace-by-fee, etc.
    public var sequence: UInt32 = 0

    /// The script for claiming the input (non-Segwit/non-Taproot).
    public var scriptSig: Data = Data()

    /// The script for claiming the input (Segit/Taproot).
    public var witnessItems: [Data] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _outPoint: TW_BitcoinV2_Proto_OutPoint? = nil
  }

  public struct TransactionOutput {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The condition for claiming the output.
    public var scriptPubkey: Data = Data()

    /// The amount of satoshis to spend.
    public var value: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct TW_BitcoinV2_Proto_TransactionPlan {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A possible error, `OK` if none.
  public var error: TW_Common_Proto_SigningError = .ok

  /// Error description.
  public var errorMessage: String = String()

  /// Selected unspent transaction outputs (subset of all input UTXOs).
  public var inputs: [TW_BitcoinV2_Proto_Input] = []

  /// Transaction outputs including a change output if applied.
  public var outputs: [TW_BitcoinV2_Proto_Output] = []

  /// Maximum available amount in all the transaction input UTXOs.
  /// That is an amount that will be spent by this transaction.
  public var availableAmount: Int64 = 0

  /// Total sending amount in all the transaction outputs.
  /// That is an amount that will be sent (including change output if applied).
  public var sendAmount: Int64 = 0

  /// The estimated `vsize` in `vbytes`.
  /// It is used to compare how much blockweight needs to be allocated to confirm a transaction.
  /// For non-segwit transactions, `vsize` = `size`.
  public var vsizeEstimate: UInt64 = 0

  /// The estimated fees of the transaction in satoshis.
  public var feeEstimate: Int64 = 0

  /// Remaining change.
  /// Zero if not applied.
  public var change: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct TW_BitcoinV2_Proto_PreSigningOutput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A possible error, `OK` if none.
  public var error: TW_Common_Proto_SigningError = .ok

  /// Error description.
  public var errorMessage: String = String()

  /// The sighashes to be signed; ECDSA for legacy and Segwit, Schnorr for Taproot.
  public var sighashes: [TW_BitcoinV2_Proto_PreSigningOutput.Sighash] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum SigningMethod: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Used for P2SH and P2PKH - standard ecdsa secp256k1 signing
    case legacy // = 0

    /// Used for P2WSH and P2WPKH - standard ecdsa secp256k1 signing
    case segwit // = 1

    /// Used for P2TR key-path and P2TR script-pay - schnorr signing
    case taproot // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .legacy
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .legacy
      case 1: self = .segwit
      case 2: self = .taproot
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .legacy: return 0
      case .segwit: return 1
      case .taproot: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public struct Sighash {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Public key used for signing.
    /// Please note it can be tweaked in case of P2TR scriptPubkey.
    public var publicKey: Data = Data()

    /// The sighash to be signed.
    public var sighash: Data = Data()

    /// Signing method to be used to sign the sighash.
    public var signingMethod: TW_BitcoinV2_Proto_PreSigningOutput.SigningMethod = .legacy

    /// Taproot tweak if `Taproot` signing method is used.
    /// Empty if there is no need to tweak the private to sign the sighash.
    public var tweak: TW_BitcoinV2_Proto_PreSigningOutput.TaprootTweak {
      get {return _tweak ?? TW_BitcoinV2_Proto_PreSigningOutput.TaprootTweak()}
      set {_tweak = newValue}
    }
    /// Returns true if `tweak` has been explicitly set.
    public var hasTweak: Bool {return self._tweak != nil}
    /// Clears the value of `tweak`. Subsequent reads from it will return its default value.
    public mutating func clearTweak() {self._tweak = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _tweak: TW_BitcoinV2_Proto_PreSigningOutput.TaprootTweak? = nil
  }

  public struct TaprootTweak {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// 32 bytes merkle root of the script tree.
    /// Empty if there are no scripts, and the private key should be tweaked without a merkle root.
    public var merkleRoot: Data = Data()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

#if swift(>=4.2)

extension TW_BitcoinV2_Proto_PreSigningOutput.SigningMethod: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [TW_BitcoinV2_Proto_PreSigningOutput.SigningMethod] = [
    .legacy,
    .segwit,
    .taproot,
  ]
}

#endif  // swift(>=4.2)

public struct TW_BitcoinV2_Proto_SigningOutput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A possible error, `OK` if none.
  public var error: TW_Common_Proto_SigningError = .ok

  /// Error description.
  public var errorMessage: String = String()

  /// Resulting transaction.
  public var transaction: TW_BitcoinV2_Proto_Transaction {
    get {return _transaction ?? TW_BitcoinV2_Proto_Transaction()}
    set {_transaction = newValue}
  }
  /// Returns true if `transaction` has been explicitly set.
  public var hasTransaction: Bool {return self._transaction != nil}
  /// Clears the value of `transaction`. Subsequent reads from it will return its default value.
  public mutating func clearTransaction() {self._transaction = nil}

  /// The encoded transaction that can be submitted to the network.
  public var encoded: Data = Data()

  /// The transaction ID (hash).
  public var txid: Data = Data()

  /// The total `vsize` in `vbytes`.
  /// It is used to compare how much blockweight needs to be allocated to confirm a transaction.
  /// For non-segwit transactions, `vsize` = `size`.
  public var vsize: UInt64 = 0

  /// Transaction weight is defined as Base transaction size * 3 + Total transaction size
  /// (ie. the same method as calculating Block weight from Base size and Total size).
  public var weight: UInt64 = 0

  /// The total and final fee of the transaction in satoshis.
  public var fee: Int64 = 0

  /// Optional. Signed transaction serialized as PSBT.
  /// Set if `SigningInput.psbt` is used.
  public var psbt: TW_BitcoinV2_Proto_Psbt {
    get {return _psbt ?? TW_BitcoinV2_Proto_Psbt()}
    set {_psbt = newValue}
  }
  /// Returns true if `psbt` has been explicitly set.
  public var hasPsbt: Bool {return self._psbt != nil}
  /// Clears the value of `psbt`. Subsequent reads from it will return its default value.
  public mutating func clearPsbt() {self._psbt = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _transaction: TW_BitcoinV2_Proto_Transaction? = nil
  fileprivate var _psbt: TW_BitcoinV2_Proto_Psbt? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "TW.BitcoinV2.Proto"

extension TW_BitcoinV2_Proto_InputSelector: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SelectAscending"),
    1: .same(proto: "SelectInOrder"),
    2: .same(proto: "SelectDescending"),
    10: .same(proto: "UseAll"),
  ]
}

extension TW_BitcoinV2_Proto_TransactionVersion: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UseDefault"),
    1: .same(proto: "V1"),
    2: .same(proto: "V2"),
  ]
}

extension TW_BitcoinV2_Proto_PublicKeyOrHash: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PublicKeyOrHash"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pubkey"),
    2: .same(proto: "hash"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.variant != nil {try decoder.handleConflictingOneOf()}
          self.variant = .pubkey(v)
        }
      }()
      case 2: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.variant != nil {try decoder.handleConflictingOneOf()}
          self.variant = .hash(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.variant {
    case .pubkey?: try {
      guard case .pubkey(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }()
    case .hash?: try {
      guard case .hash(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_BitcoinV2_Proto_PublicKeyOrHash, rhs: TW_BitcoinV2_Proto_PublicKeyOrHash) -> Bool {
    if lhs.variant != rhs.variant {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_BitcoinV2_Proto_OutPoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OutPoint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .same(proto: "vout"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.hash) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.vout) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hash.isEmpty {
      try visitor.visitSingularBytesField(value: self.hash, fieldNumber: 1)
    }
    if self.vout != 0 {
      try visitor.visitSingularUInt32Field(value: self.vout, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_BitcoinV2_Proto_OutPoint, rhs: TW_BitcoinV2_Proto_OutPoint) -> Bool {
    if lhs.hash != rhs.hash {return false}
    if lhs.vout != rhs.vout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_BitcoinV2_Proto_Input: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Input"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "out_point"),
    2: .same(proto: "value"),
    3: .standard(proto: "sighash_type"),
    4: .same(proto: "sequence"),
    5: .standard(proto: "script_builder"),
    6: .standard(proto: "script_data"),
    7: .standard(proto: "receiver_address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._outPoint) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.value) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.sighashType) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._sequence) }()
      case 5: try {
        var v: TW_BitcoinV2_Proto_Input.InputBuilder?
        var hadOneofValue = false
        if let current = self.claimingScript {
          hadOneofValue = true
          if case .scriptBuilder(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.claimingScript = .scriptBuilder(v)
        }
      }()
      case 6: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.claimingScript != nil {try decoder.handleConflictingOneOf()}
          self.claimingScript = .scriptData(v)
        }
      }()
      case 7: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.claimingScript != nil {try decoder.handleConflictingOneOf()}
          self.claimingScript = .receiverAddress(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._outPoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.value != 0 {
      try visitor.visitSingularInt64Field(value: self.value, fieldNumber: 2)
    }
    if self.sighashType != 0 {
      try visitor.visitSingularUInt32Field(value: self.sighashType, fieldNumber: 3)
    }
    try { if let v = self._sequence {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    switch self.claimingScript {
    case .scriptBuilder?: try {
      guard case .scriptBuilder(let v)? = self.claimingScript else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .scriptData?: try {
      guard case .scriptData(let v)? = self.claimingScript else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 6)
    }()
    case .receiverAddress?: try {
      guard case .receiverAddress(let v)? = self.claimingScript else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_BitcoinV2_Proto_Input, rhs: TW_BitcoinV2_Proto_Input) -> Bool {
    if lhs._outPoint != rhs._outPoint {return false}
    if lhs.value != rhs.value {return false}
    if lhs.sighashType != rhs.sighashType {return false}
    if lhs._sequence != rhs._sequence {return false}
    if lhs.claimingScript != rhs.claimingScript {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_BitcoinV2_Proto_Input.Sequence: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = TW_BitcoinV2_Proto_Input.protoMessageName + ".Sequence"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sequence"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.sequence) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sequence != 0 {
      try visitor.visitSingularUInt32Field(value: self.sequence, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_BitcoinV2_Proto_Input.Sequence, rhs: TW_BitcoinV2_Proto_Input.Sequence) -> Bool {
    if lhs.sequence != rhs.sequence {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_BitcoinV2_Proto_Input.InputBuilder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = TW_BitcoinV2_Proto_Input.protoMessageName + ".InputBuilder"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "p2pk"),
    3: .same(proto: "p2pkh"),
    5: .same(proto: "p2wpkh"),
    7: .standard(proto: "p2tr_key_path"),
    9: .standard(proto: "brc20_inscribe"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.variant != nil {try decoder.handleConflictingOneOf()}
          self.variant = .p2Pk(v)
        }
      }()
      case 3: try {
        var v: TW_BitcoinV2_Proto_PublicKeyOrHash?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .p2Pkh(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .p2Pkh(v)
        }
      }()
      case 5: try {
        var v: TW_BitcoinV2_Proto_PublicKeyOrHash?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .p2Wpkh(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .p2Wpkh(v)
        }
      }()
      case 7: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.variant != nil {try decoder.handleConflictingOneOf()}
          self.variant = .p2TrKeyPath(v)
        }
      }()
      case 9: try {
        var v: TW_BitcoinV2_Proto_Input.InputBrc20Inscription?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .brc20Inscribe(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .brc20Inscribe(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.variant {
    case .p2Pk?: try {
      guard case .p2Pk(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }()
    case .p2Pkh?: try {
      guard case .p2Pkh(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .p2Wpkh?: try {
      guard case .p2Wpkh(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .p2TrKeyPath?: try {
      guard case .p2TrKeyPath(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 7)
    }()
    case .brc20Inscribe?: try {
      guard case .brc20Inscribe(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_BitcoinV2_Proto_Input.InputBuilder, rhs: TW_BitcoinV2_Proto_Input.InputBuilder) -> Bool {
    if lhs.variant != rhs.variant {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_BitcoinV2_Proto_Input.InputTaprootScriptPath: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = TW_BitcoinV2_Proto_Input.protoMessageName + ".InputTaprootScriptPath"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "payload"),
    3: .standard(proto: "control_block"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularBytesField(value: &self.payload) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.controlBlock) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.payload.isEmpty {
      try visitor.visitSingularBytesField(value: self.payload, fieldNumber: 2)
    }
    if !self.controlBlock.isEmpty {
      try visitor.visitSingularBytesField(value: self.controlBlock, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_BitcoinV2_Proto_Input.InputTaprootScriptPath, rhs: TW_BitcoinV2_Proto_Input.InputTaprootScriptPath) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.controlBlock != rhs.controlBlock {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_BitcoinV2_Proto_Input.InputBrc20Inscription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = TW_BitcoinV2_Proto_Input.protoMessageName + ".InputBrc20Inscription"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "inscribe_to"),
    3: .same(proto: "ticker"),
    4: .standard(proto: "transfer_amount"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularBytesField(value: &self.inscribeTo) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.ticker) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.transferAmount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.inscribeTo.isEmpty {
      try visitor.visitSingularBytesField(value: self.inscribeTo, fieldNumber: 2)
    }
    if !self.ticker.isEmpty {
      try visitor.visitSingularStringField(value: self.ticker, fieldNumber: 3)
    }
    if !self.transferAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.transferAmount, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_BitcoinV2_Proto_Input.InputBrc20Inscription, rhs: TW_BitcoinV2_Proto_Input.InputBrc20Inscription) -> Bool {
    if lhs.inscribeTo != rhs.inscribeTo {return false}
    if lhs.ticker != rhs.ticker {return false}
    if lhs.transferAmount != rhs.transferAmount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_BitcoinV2_Proto_Output: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Output"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "builder"),
    3: .standard(proto: "custom_script_pubkey"),
    4: .standard(proto: "to_address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.value) }()
      case 2: try {
        var v: TW_BitcoinV2_Proto_Output.OutputBuilder?
        var hadOneofValue = false
        if let current = self.toRecipient {
          hadOneofValue = true
          if case .builder(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.toRecipient = .builder(v)
        }
      }()
      case 3: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.toRecipient != nil {try decoder.handleConflictingOneOf()}
          self.toRecipient = .customScriptPubkey(v)
        }
      }()
      case 4: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.toRecipient != nil {try decoder.handleConflictingOneOf()}
          self.toRecipient = .toAddress(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.value != 0 {
      try visitor.visitSingularInt64Field(value: self.value, fieldNumber: 1)
    }
    switch self.toRecipient {
    case .builder?: try {
      guard case .builder(let v)? = self.toRecipient else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .customScriptPubkey?: try {
      guard case .customScriptPubkey(let v)? = self.toRecipient else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    }()
    case .toAddress?: try {
      guard case .toAddress(let v)? = self.toRecipient else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_BitcoinV2_Proto_Output, rhs: TW_BitcoinV2_Proto_Output) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.toRecipient != rhs.toRecipient {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_BitcoinV2_Proto_Output.OutputBuilder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = TW_BitcoinV2_Proto_Output.protoMessageName + ".OutputBuilder"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "p2sh"),
    2: .same(proto: "p2pk"),
    3: .same(proto: "p2pkh"),
    4: .same(proto: "p2wsh"),
    5: .same(proto: "p2wpkh"),
    6: .standard(proto: "p2tr_key_path"),
    7: .standard(proto: "p2tr_script_path"),
    8: .standard(proto: "p2tr_dangerous_assume_tweaked"),
    9: .standard(proto: "brc20_inscribe"),
    12: .standard(proto: "op_return"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: TW_BitcoinV2_Proto_Output.RedeemScriptOrHash?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .p2Sh(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .p2Sh(v)
        }
      }()
      case 2: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.variant != nil {try decoder.handleConflictingOneOf()}
          self.variant = .p2Pk(v)
        }
      }()
      case 3: try {
        var v: TW_BitcoinV2_Proto_PublicKeyOrHash?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .p2Pkh(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .p2Pkh(v)
        }
      }()
      case 4: try {
        var v: TW_BitcoinV2_Proto_Output.RedeemScriptOrHash?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .p2Wsh(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .p2Wsh(v)
        }
      }()
      case 5: try {
        var v: TW_BitcoinV2_Proto_PublicKeyOrHash?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .p2Wpkh(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .p2Wpkh(v)
        }
      }()
      case 6: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.variant != nil {try decoder.handleConflictingOneOf()}
          self.variant = .p2TrKeyPath(v)
        }
      }()
      case 7: try {
        var v: TW_BitcoinV2_Proto_Output.OutputTaprootScriptPath?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .p2TrScriptPath(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .p2TrScriptPath(v)
        }
      }()
      case 8: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.variant != nil {try decoder.handleConflictingOneOf()}
          self.variant = .p2TrDangerousAssumeTweaked(v)
        }
      }()
      case 9: try {
        var v: TW_BitcoinV2_Proto_Output.OutputBrc20Inscription?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .brc20Inscribe(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .brc20Inscribe(v)
        }
      }()
      case 12: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.variant != nil {try decoder.handleConflictingOneOf()}
          self.variant = .opReturn(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.variant {
    case .p2Sh?: try {
      guard case .p2Sh(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .p2Pk?: try {
      guard case .p2Pk(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }()
    case .p2Pkh?: try {
      guard case .p2Pkh(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .p2Wsh?: try {
      guard case .p2Wsh(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .p2Wpkh?: try {
      guard case .p2Wpkh(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .p2TrKeyPath?: try {
      guard case .p2TrKeyPath(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 6)
    }()
    case .p2TrScriptPath?: try {
      guard case .p2TrScriptPath(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .p2TrDangerousAssumeTweaked?: try {
      guard case .p2TrDangerousAssumeTweaked(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 8)
    }()
    case .brc20Inscribe?: try {
      guard case .brc20Inscribe(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .opReturn?: try {
      guard case .opReturn(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 12)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_BitcoinV2_Proto_Output.OutputBuilder, rhs: TW_BitcoinV2_Proto_Output.OutputBuilder) -> Bool {
    if lhs.variant != rhs.variant {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_BitcoinV2_Proto_Output.RedeemScriptOrHash: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = TW_BitcoinV2_Proto_Output.protoMessageName + ".RedeemScriptOrHash"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "redeem_script"),
    2: .same(proto: "hash"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.variant != nil {try decoder.handleConflictingOneOf()}
          self.variant = .redeemScript(v)
        }
      }()
      case 2: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.variant != nil {try decoder.handleConflictingOneOf()}
          self.variant = .hash(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.variant {
    case .redeemScript?: try {
      guard case .redeemScript(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }()
    case .hash?: try {
      guard case .hash(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_BitcoinV2_Proto_Output.RedeemScriptOrHash, rhs: TW_BitcoinV2_Proto_Output.RedeemScriptOrHash) -> Bool {
    if lhs.variant != rhs.variant {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_BitcoinV2_Proto_Output.OutputTaprootScriptPath: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = TW_BitcoinV2_Proto_Output.protoMessageName + ".OutputTaprootScriptPath"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "internal_key"),
    2: .standard(proto: "merkle_root"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.internalKey) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.merkleRoot) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.internalKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.internalKey, fieldNumber: 1)
    }
    if !self.merkleRoot.isEmpty {
      try visitor.visitSingularBytesField(value: self.merkleRoot, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_BitcoinV2_Proto_Output.OutputTaprootScriptPath, rhs: TW_BitcoinV2_Proto_Output.OutputTaprootScriptPath) -> Bool {
    if lhs.internalKey != rhs.internalKey {return false}
    if lhs.merkleRoot != rhs.merkleRoot {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_BitcoinV2_Proto_Output.OutputBrc20Inscription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = TW_BitcoinV2_Proto_Output.protoMessageName + ".OutputBrc20Inscription"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "inscribe_to"),
    2: .same(proto: "ticker"),
    3: .standard(proto: "transfer_amount"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.inscribeTo) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.ticker) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.transferAmount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.inscribeTo.isEmpty {
      try visitor.visitSingularBytesField(value: self.inscribeTo, fieldNumber: 1)
    }
    if !self.ticker.isEmpty {
      try visitor.visitSingularStringField(value: self.ticker, fieldNumber: 2)
    }
    if !self.transferAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.transferAmount, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_BitcoinV2_Proto_Output.OutputBrc20Inscription, rhs: TW_BitcoinV2_Proto_Output.OutputBrc20Inscription) -> Bool {
    if lhs.inscribeTo != rhs.inscribeTo {return false}
    if lhs.ticker != rhs.ticker {return false}
    if lhs.transferAmount != rhs.transferAmount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_BitcoinV2_Proto_ChainInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChainInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "p2pkh_prefix"),
    2: .standard(proto: "p2sh_prefix"),
    3: .same(proto: "hrp"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.p2PkhPrefix) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.p2ShPrefix) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.hrp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.p2PkhPrefix != 0 {
      try visitor.visitSingularUInt32Field(value: self.p2PkhPrefix, fieldNumber: 1)
    }
    if self.p2ShPrefix != 0 {
      try visitor.visitSingularUInt32Field(value: self.p2ShPrefix, fieldNumber: 2)
    }
    if !self.hrp.isEmpty {
      try visitor.visitSingularStringField(value: self.hrp, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_BitcoinV2_Proto_ChainInfo, rhs: TW_BitcoinV2_Proto_ChainInfo) -> Bool {
    if lhs.p2PkhPrefix != rhs.p2PkhPrefix {return false}
    if lhs.p2ShPrefix != rhs.p2ShPrefix {return false}
    if lhs.hrp != rhs.hrp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_BitcoinV2_Proto_TransactionBuilder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransactionBuilder"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .standard(proto: "lock_time"),
    3: .same(proto: "inputs"),
    4: .same(proto: "outputs"),
    5: .standard(proto: "input_selector"),
    6: .standard(proto: "fee_per_vb"),
    7: .standard(proto: "change_output"),
    8: .standard(proto: "max_amount_output"),
    14: .standard(proto: "fixed_dust_threshold"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.version) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.lockTime) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.inputs) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.outputs) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.inputSelector) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.feePerVb) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._changeOutput) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._maxAmountOutput) }()
      case 14: try {
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {
          if self.dustPolicy != nil {try decoder.handleConflictingOneOf()}
          self.dustPolicy = .fixedDustThreshold(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.version != .useDefault {
      try visitor.visitSingularEnumField(value: self.version, fieldNumber: 1)
    }
    if self.lockTime != 0 {
      try visitor.visitSingularUInt32Field(value: self.lockTime, fieldNumber: 2)
    }
    if !self.inputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.inputs, fieldNumber: 3)
    }
    if !self.outputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.outputs, fieldNumber: 4)
    }
    if self.inputSelector != .selectAscending {
      try visitor.visitSingularEnumField(value: self.inputSelector, fieldNumber: 5)
    }
    if self.feePerVb != 0 {
      try visitor.visitSingularInt64Field(value: self.feePerVb, fieldNumber: 6)
    }
    try { if let v = self._changeOutput {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._maxAmountOutput {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try { if case .fixedDustThreshold(let v)? = self.dustPolicy {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 14)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_BitcoinV2_Proto_TransactionBuilder, rhs: TW_BitcoinV2_Proto_TransactionBuilder) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.lockTime != rhs.lockTime {return false}
    if lhs.inputs != rhs.inputs {return false}
    if lhs.outputs != rhs.outputs {return false}
    if lhs.inputSelector != rhs.inputSelector {return false}
    if lhs.feePerVb != rhs.feePerVb {return false}
    if lhs._changeOutput != rhs._changeOutput {return false}
    if lhs._maxAmountOutput != rhs._maxAmountOutput {return false}
    if lhs.dustPolicy != rhs.dustPolicy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_BitcoinV2_Proto_Psbt: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Psbt"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "psbt"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.psbt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.psbt.isEmpty {
      try visitor.visitSingularBytesField(value: self.psbt, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_BitcoinV2_Proto_Psbt, rhs: TW_BitcoinV2_Proto_Psbt) -> Bool {
    if lhs.psbt != rhs.psbt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_BitcoinV2_Proto_SigningInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SigningInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "private_keys"),
    2: .standard(proto: "public_keys"),
    3: .standard(proto: "chain_info"),
    4: .standard(proto: "dangerous_use_fixed_schnorr_rng"),
    10: .same(proto: "builder"),
    11: .same(proto: "psbt"),
  ]

  fileprivate class _StorageClass {
    var _privateKeys: [Data] = []
    var _publicKeys: [Data] = []
    var _chainInfo: TW_BitcoinV2_Proto_ChainInfo? = nil
    var _dangerousUseFixedSchnorrRng: Bool = false
    var _transaction: TW_BitcoinV2_Proto_SigningInput.OneOf_Transaction?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _privateKeys = source._privateKeys
      _publicKeys = source._publicKeys
      _chainInfo = source._chainInfo
      _dangerousUseFixedSchnorrRng = source._dangerousUseFixedSchnorrRng
      _transaction = source._transaction
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeRepeatedBytesField(value: &_storage._privateKeys) }()
        case 2: try { try decoder.decodeRepeatedBytesField(value: &_storage._publicKeys) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._chainInfo) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._dangerousUseFixedSchnorrRng) }()
        case 10: try {
          var v: TW_BitcoinV2_Proto_TransactionBuilder?
          var hadOneofValue = false
          if let current = _storage._transaction {
            hadOneofValue = true
            if case .builder(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._transaction = .builder(v)
          }
        }()
        case 11: try {
          var v: TW_BitcoinV2_Proto_Psbt?
          var hadOneofValue = false
          if let current = _storage._transaction {
            hadOneofValue = true
            if case .psbt(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._transaction = .psbt(v)
          }
        }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._privateKeys.isEmpty {
        try visitor.visitRepeatedBytesField(value: _storage._privateKeys, fieldNumber: 1)
      }
      if !_storage._publicKeys.isEmpty {
        try visitor.visitRepeatedBytesField(value: _storage._publicKeys, fieldNumber: 2)
      }
      try { if let v = _storage._chainInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if _storage._dangerousUseFixedSchnorrRng != false {
        try visitor.visitSingularBoolField(value: _storage._dangerousUseFixedSchnorrRng, fieldNumber: 4)
      }
      switch _storage._transaction {
      case .builder?: try {
        guard case .builder(let v)? = _storage._transaction else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }()
      case .psbt?: try {
        guard case .psbt(let v)? = _storage._transaction else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_BitcoinV2_Proto_SigningInput, rhs: TW_BitcoinV2_Proto_SigningInput) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._privateKeys != rhs_storage._privateKeys {return false}
        if _storage._publicKeys != rhs_storage._publicKeys {return false}
        if _storage._chainInfo != rhs_storage._chainInfo {return false}
        if _storage._dangerousUseFixedSchnorrRng != rhs_storage._dangerousUseFixedSchnorrRng {return false}
        if _storage._transaction != rhs_storage._transaction {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_BitcoinV2_Proto_Transaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Transaction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .standard(proto: "lock_time"),
    3: .same(proto: "inputs"),
    4: .same(proto: "outputs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.version) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.lockTime) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.inputs) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.outputs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.version != 0 {
      try visitor.visitSingularInt32Field(value: self.version, fieldNumber: 1)
    }
    if self.lockTime != 0 {
      try visitor.visitSingularUInt32Field(value: self.lockTime, fieldNumber: 2)
    }
    if !self.inputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.inputs, fieldNumber: 3)
    }
    if !self.outputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.outputs, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_BitcoinV2_Proto_Transaction, rhs: TW_BitcoinV2_Proto_Transaction) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.lockTime != rhs.lockTime {return false}
    if lhs.inputs != rhs.inputs {return false}
    if lhs.outputs != rhs.outputs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_BitcoinV2_Proto_Transaction.TransactionInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = TW_BitcoinV2_Proto_Transaction.protoMessageName + ".TransactionInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "out_point"),
    2: .same(proto: "sequence"),
    3: .standard(proto: "script_sig"),
    4: .standard(proto: "witness_items"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._outPoint) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.sequence) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.scriptSig) }()
      case 4: try { try decoder.decodeRepeatedBytesField(value: &self.witnessItems) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._outPoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.sequence != 0 {
      try visitor.visitSingularUInt32Field(value: self.sequence, fieldNumber: 2)
    }
    if !self.scriptSig.isEmpty {
      try visitor.visitSingularBytesField(value: self.scriptSig, fieldNumber: 3)
    }
    if !self.witnessItems.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.witnessItems, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_BitcoinV2_Proto_Transaction.TransactionInput, rhs: TW_BitcoinV2_Proto_Transaction.TransactionInput) -> Bool {
    if lhs._outPoint != rhs._outPoint {return false}
    if lhs.sequence != rhs.sequence {return false}
    if lhs.scriptSig != rhs.scriptSig {return false}
    if lhs.witnessItems != rhs.witnessItems {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_BitcoinV2_Proto_Transaction.TransactionOutput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = TW_BitcoinV2_Proto_Transaction.protoMessageName + ".TransactionOutput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "script_pubkey"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.scriptPubkey) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.scriptPubkey.isEmpty {
      try visitor.visitSingularBytesField(value: self.scriptPubkey, fieldNumber: 1)
    }
    if self.value != 0 {
      try visitor.visitSingularInt64Field(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_BitcoinV2_Proto_Transaction.TransactionOutput, rhs: TW_BitcoinV2_Proto_Transaction.TransactionOutput) -> Bool {
    if lhs.scriptPubkey != rhs.scriptPubkey {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_BitcoinV2_Proto_TransactionPlan: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransactionPlan"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .standard(proto: "error_message"),
    3: .same(proto: "inputs"),
    4: .same(proto: "outputs"),
    5: .standard(proto: "available_amount"),
    6: .standard(proto: "send_amount"),
    7: .standard(proto: "vsize_estimate"),
    8: .standard(proto: "fee_estimate"),
    9: .same(proto: "change"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.error) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMessage) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.inputs) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.outputs) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.availableAmount) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.sendAmount) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.vsizeEstimate) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.feeEstimate) }()
      case 9: try { try decoder.decodeSingularInt64Field(value: &self.change) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.error != .ok {
      try visitor.visitSingularEnumField(value: self.error, fieldNumber: 1)
    }
    if !self.errorMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMessage, fieldNumber: 2)
    }
    if !self.inputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.inputs, fieldNumber: 3)
    }
    if !self.outputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.outputs, fieldNumber: 4)
    }
    if self.availableAmount != 0 {
      try visitor.visitSingularInt64Field(value: self.availableAmount, fieldNumber: 5)
    }
    if self.sendAmount != 0 {
      try visitor.visitSingularInt64Field(value: self.sendAmount, fieldNumber: 6)
    }
    if self.vsizeEstimate != 0 {
      try visitor.visitSingularUInt64Field(value: self.vsizeEstimate, fieldNumber: 7)
    }
    if self.feeEstimate != 0 {
      try visitor.visitSingularInt64Field(value: self.feeEstimate, fieldNumber: 8)
    }
    if self.change != 0 {
      try visitor.visitSingularInt64Field(value: self.change, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_BitcoinV2_Proto_TransactionPlan, rhs: TW_BitcoinV2_Proto_TransactionPlan) -> Bool {
    if lhs.error != rhs.error {return false}
    if lhs.errorMessage != rhs.errorMessage {return false}
    if lhs.inputs != rhs.inputs {return false}
    if lhs.outputs != rhs.outputs {return false}
    if lhs.availableAmount != rhs.availableAmount {return false}
    if lhs.sendAmount != rhs.sendAmount {return false}
    if lhs.vsizeEstimate != rhs.vsizeEstimate {return false}
    if lhs.feeEstimate != rhs.feeEstimate {return false}
    if lhs.change != rhs.change {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_BitcoinV2_Proto_PreSigningOutput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PreSigningOutput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .standard(proto: "error_message"),
    4: .same(proto: "sighashes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.error) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMessage) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.sighashes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.error != .ok {
      try visitor.visitSingularEnumField(value: self.error, fieldNumber: 1)
    }
    if !self.errorMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMessage, fieldNumber: 2)
    }
    if !self.sighashes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sighashes, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_BitcoinV2_Proto_PreSigningOutput, rhs: TW_BitcoinV2_Proto_PreSigningOutput) -> Bool {
    if lhs.error != rhs.error {return false}
    if lhs.errorMessage != rhs.errorMessage {return false}
    if lhs.sighashes != rhs.sighashes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_BitcoinV2_Proto_PreSigningOutput.SigningMethod: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Legacy"),
    1: .same(proto: "Segwit"),
    2: .same(proto: "Taproot"),
  ]
}

extension TW_BitcoinV2_Proto_PreSigningOutput.Sighash: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = TW_BitcoinV2_Proto_PreSigningOutput.protoMessageName + ".Sighash"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "public_key"),
    2: .same(proto: "sighash"),
    3: .standard(proto: "signing_method"),
    4: .same(proto: "tweak"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.publicKey) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.sighash) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.signingMethod) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._tweak) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.publicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicKey, fieldNumber: 1)
    }
    if !self.sighash.isEmpty {
      try visitor.visitSingularBytesField(value: self.sighash, fieldNumber: 2)
    }
    if self.signingMethod != .legacy {
      try visitor.visitSingularEnumField(value: self.signingMethod, fieldNumber: 3)
    }
    try { if let v = self._tweak {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_BitcoinV2_Proto_PreSigningOutput.Sighash, rhs: TW_BitcoinV2_Proto_PreSigningOutput.Sighash) -> Bool {
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.sighash != rhs.sighash {return false}
    if lhs.signingMethod != rhs.signingMethod {return false}
    if lhs._tweak != rhs._tweak {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_BitcoinV2_Proto_PreSigningOutput.TaprootTweak: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = TW_BitcoinV2_Proto_PreSigningOutput.protoMessageName + ".TaprootTweak"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "merkle_root"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.merkleRoot) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.merkleRoot.isEmpty {
      try visitor.visitSingularBytesField(value: self.merkleRoot, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_BitcoinV2_Proto_PreSigningOutput.TaprootTweak, rhs: TW_BitcoinV2_Proto_PreSigningOutput.TaprootTweak) -> Bool {
    if lhs.merkleRoot != rhs.merkleRoot {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_BitcoinV2_Proto_SigningOutput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SigningOutput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .standard(proto: "error_message"),
    3: .same(proto: "transaction"),
    4: .same(proto: "encoded"),
    5: .same(proto: "txid"),
    6: .same(proto: "vsize"),
    7: .same(proto: "weight"),
    8: .same(proto: "fee"),
    9: .same(proto: "psbt"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.error) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMessage) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._transaction) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.encoded) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.txid) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.vsize) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.weight) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.fee) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._psbt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.error != .ok {
      try visitor.visitSingularEnumField(value: self.error, fieldNumber: 1)
    }
    if !self.errorMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMessage, fieldNumber: 2)
    }
    try { if let v = self._transaction {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.encoded.isEmpty {
      try visitor.visitSingularBytesField(value: self.encoded, fieldNumber: 4)
    }
    if !self.txid.isEmpty {
      try visitor.visitSingularBytesField(value: self.txid, fieldNumber: 5)
    }
    if self.vsize != 0 {
      try visitor.visitSingularUInt64Field(value: self.vsize, fieldNumber: 6)
    }
    if self.weight != 0 {
      try visitor.visitSingularUInt64Field(value: self.weight, fieldNumber: 7)
    }
    if self.fee != 0 {
      try visitor.visitSingularInt64Field(value: self.fee, fieldNumber: 8)
    }
    try { if let v = self._psbt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_BitcoinV2_Proto_SigningOutput, rhs: TW_BitcoinV2_Proto_SigningOutput) -> Bool {
    if lhs.error != rhs.error {return false}
    if lhs.errorMessage != rhs.errorMessage {return false}
    if lhs._transaction != rhs._transaction {return false}
    if lhs.encoded != rhs.encoded {return false}
    if lhs.txid != rhs.txid {return false}
    if lhs.vsize != rhs.vsize {return false}
    if lhs.weight != rhs.weight {return false}
    if lhs.fee != rhs.fee {return false}
    if lhs._psbt != rhs._psbt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
